---
title: "Podstawowe struktury danych, funkcje i pliki"
author: " Mateusz Rzeszutek"
author-meta: "A"
date: today
format: 
  html:
    code-fold: show
    code-block-bg: true 
    code-block-border-left: blue
    code-tools: true
    number-sections: true
    number-depth: 6
    toc: true
    toc-depth: 4
    toc-location: right
    toc-title: Spis Treści
    embed-resources: true
    smooth-scroll: true
    self-contained: true
    anchor-sections: true
    theme: 
        light: flatly
        dark: solar
    fontsize: 1.0em
    linestretch: 1.5
execute: 
  echo: true
  error: false
  warning: false
  output: true
---

<style type="text/css"> body {text-align: justify}  </style>

## Struktury i sekwencje danych 


### Tuples - krotki
***

**Tuples** - jest sekwencja **niezmienna**. Tworzymy ją nawiasami. W okreslonych sytuacjach można pomnąć nawiasy 

```{python}
tup = (2, 5, 8)
tup = 5, 5, 6
tup
```

Dowolną sekwencję można przekonwertować na obiekt `tuple` lub iterator.

```{python}
a = range(4)
type(tuple(a))
```

```{python}
b = tuple('string') 
b
```

Indeksowanie odbywa się za pomocą nawiasó kwadratowy `[]`

```{python}
print(b[0] , b[3])
```

**nest tuple** - bardziej skomplikowane krotki - trzeba stosować nawiasy do wydzielenie elemntów zagnieżdzonych.

```{python}
nest_tup = (3,6,9), (2,4)
nest_tup
```

Nie można modyfikować struktury obiektów `tuple`. Natomiast można zmodyfikować obiekty zagnieżdzone, które są modyfikowalne np. `list`.

```{python}
nest = ('foo', [1,2], True)

print(f"Obiekt nest = {nest}, \n  Jego typ = {type(nest)}")
```

Spróbujemy zmienić sekwencje `True` na wartość `False` w obiekcie `tuple`  

```{python}
#| eval: false
nest[2] = False
```

Nie zadziałoało ponieważ nie mozna modyfikować obiektu `tuple`. Można za to zmodyfikować wewnętrzny obiekt np. `list`.

```{python}
nest[1].append(3)
nest
```

Obiekty `tuple` można łączyć w celu stworzenia bardziej złożonych obiektów:

```{python}
new_nest = nest + ("test", [2,4,6], False)
new_nest
```

Mnożenie `tuple` przez liczbe całkowitą - jest powielaniem elmentów `tuple`

```{python}
nest = ('foo', [1,2], True)
nest * 3
```

:::{.callout-tip appearance="simple"}
Zauważ, że nowy obiekt powstał z odniesień do dwóch istniejacych obiektów.
:::


#### Rozpakowanie tuple 
*** 
Można przypisać wiele zmienych do obiektu tuple. Python wykona działąnie tzw. rozpakowania. 

```{python}
a, b, c, = nest

print(f" a = {a}, \n b = {b}, \n c = {c}")
```

Otwórz w panelu VS code `Jupyter:Variables` i sprawdźć typy nowych zmiennych. 

Zagnieżdzone obiekty `tuple` też można rozpakować, ale należy zastosować odpowiednią skladnie.  

```{python}
tup = 2,3,4,(3,4)
a, b, c, (d, e) = tup 

print(f" a = {a}, \n b = {b}, \n c = {c}, \n c = {d}, \n c = {e}.")
```

Tym sposobem można zmieniać nazwy zmiennych.

```{python}
a, b, = 1, 2
print(a, b)

b, a = a, b
print(a, b)
```

Powszechnym sposobem ropakowania krotek jest ich iteracja po sekwencji

```{python}
seq = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
for a, b, c in seq:
  print(f" a = {a}, b ={b}, c = {c}")
```

Można wybrać również kilka elementów z początki `tuple`. Przydatny jest operator `*`.

```{python}
values = 1, 2, 3, 4, 5, 
a, b, *rest = values
print( a,"\n",b,"\n",rest)
```

Ten restbit jest czasem czymś, co chcesz odrzuci 
nie ma nic specjalnego w restnazwie. Zgodnie z konwencją, wielu programistów Pythona używa znaku podkreślenia `(_)` dla niechcianych zmiennych:

```{python}
a, b, *_ = values
print( a,"\n",b,"\n",_)
```


#### Metody tuple
***

Ponieważ rozmiar i zawartość krotki nie mogą być modyfikowane, **metody instancji** są bardzo lekkie. Szczególnie przydatny (dostępny również na obiektach `list`) jest `count`, który zlicza liczbę wystąpień wartości:

```{python}
a = (1, 2, 2, 2, 3, 4, 2)
print(f"index = {a.index(3)}, \n count = {a.count(2)}")
```


### Lista 
***

W przeciwieństwie do krotek, listy mają zmienną długość, a ich zawartość można modyfikować w miejscu. Listy są zmienne. Możesz je zdefiniować za pomocą nawiasów kwadratowych `[]` lub za pomocą `list` funkcji typu:

```{python}
a_list = [2, 4, 7, None]
a_list
```

```{python}
nest = ('foo', [1,2], True)
b_list = list(nest)
b_list
```

```{python}
b_list[1] = 7
b_list
```

Listy i krotki są semantycznie podobne (chociaż krotki nie mogą być modyfikowane) i mogą być używane zamiennie w wielu funkcjach. 

Wbudowana `list` funkcja jest często używana w przetwarzaniu danych jako sposób na zmaterializowanie wyrażenia iteratora lub generatora:

```{python}
gen = range(0,10)
gen
```

```{python}
gen = range(0,10)
list(gen)
```


#### Dodawanie i usuwanie elementów 
***
Można

* metoda `append` - dodawać na końcu 
* metoda `insert` - dodawać z indeksem
* metoda `pop` - usuwa element w określonej pozycji
* metoda `remove` - usuwa element po jego nazwie

```{python}
b_list.append("next element") 
b_list
```

```{python}
b_list.insert(0, "first") 
b_list
```

:::{.callout-note appearance="simple"}
`insert` jest kosztowny obliczeniowo w porównaniu z `append`, ponieważ odniesienia do kolejnych elementów muszą zostać przesunięte wewnętrznie, aby zrobić miejsce na nowy element. Jeśli potrzebujesz wstawić elementy zarówno na początku, jak i na końcu sekwencji, możesz chcieć zbadać `collections.deque` dwustronną kolejkę, która jest zoptymalizowana do tego celu i znajduje się w standardowej bibliotece Pythona.
:::

```{python}
b_list.pop(0) 
b_list
```

```{python}
b_list.remove("foo") 
b_list
```


Sprawdzanie warunkowe:

```{python}
"foo" in b_list 
```

```{python}
"foo" not in b_list
```

::: {.callout-note appearance="simple"}
Sprawdzanie w listach jest bardzo wolne ponieważ liniowego skanowania wartosci listy.
:::


#### Łączenie list
***
Podobnie jak w tuple dodawanie elementów odbywa się przez "+"

```{python}
[4, 5, "foo", None] + [7, 8, 9, (2, 3)]
```

Można dodawac kolejne elmenty metodą `extend`. `extend` - jest znacznie szybsze niż dodawanie.

```{python}
x = [4, None, "foo"]
x.extend([7, 8, (2, 3)])
x
```


#### Sortowanie 
***

`sort` funkcja:

```{python}
a = [7, 4, 2, 9, 5, 7, 8, 2]
a.sort()
a
```

Funkcja ta ma kilka różnych argumentów, które bywają przydatne. Np. sortowanie po długości znaków.

```{python}
b = ["Marcin", "Adam", "Miroslaw", "Zbigniew", "Piotr", "Antoni", "Jarosław"]
b.sort(key = len)
b
```


#### Indeksowanie
***

Do indeksowannia list służą operatory `[]` oraz `:`.

```{python}
a[1:3]
```

Można podmienić wybrane elementy w listach. 

```{python}
print(a)
a[3:5] = [6, 3] 
a
```

Indeksowanie mozna zapisac stosując ustawienia domyślne. Dwa pierwsze:
```{python}
a[:2]
```

Dwa ostatnie:

```{python}
a[2:]
```

Indeksy ujemne przecinają sekwencję względem końca. 

```{python}
a[-4:]
```

Krojenie semantyki wymaga trochę przyzwyczajenia, zwłaszcza jeśli pochodzisz z R lub MATLAB. Zobacz rysunek  3.1 , aby zobaczyć pomocną ilustrację dzielenia z dodatnimi i ujemnymi liczbami całkowitymi. Na rysunku indeksy są pokazane na „krawędziach pojemnika”, aby pomóc pokazać, gdzie selekcje plasterków zaczynają się i kończą przy użyciu indeksów dodatnich lub ujemnych.

![](fig_to_qmd/rys_4.png)

Operator :: mozna użyć jako krok, wybierz co drugi:

```{python}
a.pop(0) # usuwam pierwszą 2 dla lepszego zrozumienia przykładu
print(a)
a[::2]
```

Minus pozwala na odwrócenie sortowania

```{python}
print(a)
a[::-1]
```

### Dict
***

Słownik lub dictmoże być najważniejszą wbudowaną strukturą danych Pythona. Słownik przechowuje kolekcję par klucz-wartość (*key-value*), gdzie klucz i wartość są obiektami Pythona. Wartość można wygodnie pobrać, wstawić, zmodyfikować lub usunąć przy użyciu określonego klucza. Jednym ze sposobów tworzenia słownika jest użycie nawiasów klamrowych {} i dwukropków do oddzielenia kluczy i wartości:


```{python}
pusty_dict = {}
d1 = {"a": "cos", "b": [1, 2, 3, 4]}
d1
```

Można wstawic coś korzystając z `[]` oraz indeksować po kluczu `key`.

```{python}
d1[7] = "integer"
print(f" a = {d1['a']} \n b = {d1['b']} \n 7 = {d1[7]} ")
```

Operacje logiczne, odnoszą sie do kluacza a nie wartości występujących pod kluczem. 

```{python}
"a"   in d1
"cos" in d1 
```

Można usuwac wartości za pomocą słowa kluczowego `del` lub metody `pop`

```{python}
# dodamy key 5 and value [1, 2, 3]
d1[5] = [1, 2, 3] 
d1
```

```{python}
# usuwamy
del d1[5] 
d1
```

```{python}
# ponownie dodamy key 5 and value [1, 2, 3]
d1[5] = [1, 2, 3] 
d1
```

```{python}
d1.pop(5) 
d1
```

Metoda `keys` i `values` udostępnia odpowiednio iteratory kluczy i wartości słownika.

```{python}
list(d1.keys())
```

```{python}
list(d1.values())
```

Iteracja po kluczu `key` słownika `dictionary`. 

```{python}
list(d1.items())
```

Można scalać podobne słowniki metedą `update`. Istniejące `key` zostaną nadpisane. 

```{python}
d2 = {"b" : 'fooo', "c": 12}
d1.update(d2)
d1
```

Sprawdź co stało się z wartościami klucza `b`, dodakowo obiekt otrzymał 4 klucz `c`. 


#### Tworzenie dict z sekwencji
***

Często zdarza się, że od czasu do czasu pojawiają się dwie sekwencje, które chcesz sparować pod względem elementów w słowniku. Na początek możesz napisać taki kod:

```{python}
#| eval: false
mapping = {}
for key, value in zip(key_list, value_list):
    mapping[key] = value
```

Ponieważ słownik jest zasadniczo zbiorem 2-krotek, dictfunkcja akceptuje listę 2-krotek:

```{python}
tup = zip(range(5), reversed(range(5)))
mapping = dict(tup)
mapping
```

Spróbujmy jeszcze raz:

```{python}
mapping = dict(
  zip(
    ('a', 'b', 'c', 'd', 'e'), 
    reversed(range(5))
    )
  ) 
mapping
```


#### Wartości domyślne
***

`get` - zwraca wartość na podstawie klucza
`pop` - usuwa klucz i zwraca jego wartość

```{python}
#| eval: false
mapping.get('a')
mapping.pop('b')
```

W przypadku ustawiania wartości może się zdarzyć, że wartości w słowniku są innym rodzajem kolekcji, na przykład listą. Na przykład możesz sobie wyobrazić kategoryzowanie **listy słów** według ich pierwszych liter jako słownik `list`:

```{python}
words = ["apple", "bat", "bar", "atom", "book"]

by_letter = {}

for word in words:
    letter = word[0]
    if letter not in by_letter:
        by_letter[letter] = [word]
    else:
        by_letter[letter].append(word)

by_letter
```

Aby uprościć ten przykłąd można użyż metody `setdefault`. Zapisać to można w ten sposób:

```{python}
words = ["apple", "bat", "bar", "atom", "book"]

by_letter = {}

for word in words:
    letter = word[0]
    by_letter.setdefault(letter, []).append(word)

by_letter
```

Moduł `collections` ma użyteczną klasę `defaultdict`, która jeszcze bardziej to ułatwia. Aby go utworzyć, przekazujesz typ lub funkcję do generowania wartości domyślnej dla każdego `slot` w słowniku:


```{python}
from collections import defaultdict

by_letter = defaultdict(list)

for word in words:
    by_letter[word[0]].append(word)

by_letter
```


#### Typy kluczy `key` w słwoniku 
***

Podczas gdy wartościami słownika mogą być dowolne obiekty Pythona, klucze generalnie muszą być niezmiennymi obiektami, takimi jak typy skalarne **(int, float, string)** lub krotki `tuple` (wszystkie obiekty w krotce też muszą być niezmienne). Technicznym terminem jest tutaj **hashability**. Możesz sprawdzić, czy obiekt jest mieszalny (może być używany jako klucz w słowniku) za pomocą `hash` funkcji:

```{python}
hash("string")
```

```{python}
hash((1,2, (2, 3)))
```

```{python}
#| eval: false
hash((1, 2, [3, 4])) # list [3, 4] is mutable 
```

Ostatnie polecenie zwraca błąd. Lista nie może być `key` in `dict` ponieważ jest to obiekt zmienny.  W celu użycia `list` jako klucza w słowniku należy wykonać konwersję na `tuple`

```{python}
d = {}
d[tuple([1, 2, 3, 4])] = 5
d
```


### Set
***
`Set` to nieuporządkowany zbiór unikalnych elementów. Tworzymy go przy użyciu funkcji `set` lub `{}`

```{python}
d = {1,2,3} 
d
```

```{python}
d = set([1, 2, 4]) 
d
```

`Set`wspierają matematyczne operacje takie jak  `union`, `intersection`, `difference`, i `symmetric difference`. 

```{python}
a = {1, 2, 3, 4, 5}
b = {3, 4, 5, 6, 7, 8}
```

`union` lub `|` jest zbiorem odrębnych elemtów np:

```{python}
a.union(b)
a | b
```

`intersection` lub `&` zwraca informacje o tym co występuje w obydwu zbiorach

```{python}
a.intersection(b)
a & b
```

Wiele przykłądów: 


| Funkcja                 | równoważny      | Opis                                                                                             |
|:------------------------|:---------------:|:-------------------------------------------------------------------------------------------------|
|	`a.add(b)`	 |	Nie dotyczy	|	Dodaj element `b` do zestawua	|
|	`a.clear()`  |	Nie dotyczy	|	Zresetuj zestaw `a` do stanu pustego	|
|	`a.remove(b)`	|	Nie dotyczy	|	Usuń element `b` z zestawu `a`	|
|	`a.pop()` |	Nie dotyczy	|	Usuń dowolny element ze zbioru `a`, `KeyError` jeśli zbiór jest pusty	|
|	`a.union(b)`	|	a | b	  |	Unikalne elementy w `a` i `b`	|
|	`a.update(b)`	|	a |= b	|	Ustaw zawartość `a` jako sumę elementów w `a` i `b`	|
|	`a.intersection(b)`	|	a & b	|	Wszystkie elementy w obu `a` i `b`	|
|	`a.intersection_update(b)`	|	a &= b	|	Ustaw zawartość `a` jako przecięcie elementów w `a` i `b`	|
|	`a.difference(b)`	|	a - b	|	Elementy `a` których nie ma `b`	|
|	`a.difference_update(b)`	|	a -= b	|	Ustaw `a` na elementy `a`, których nie ma `b`	|
|	`a.symmetric_difference(b)`	|	a ^ b	|	Wszystkie elementy w jednym `a` lub , `b` ale nie w obu	|
|	`a.symmetric_difference_update(b)`	|	a ^= b	|	Ustaw `a` tak, aby zawierał elementy w jednym `a` lub `b`, ale nie w obu	|
|	`a.issubset(b)`	|	<=	|	`True` jeśli wszystkie elementy `a` są zawarte w `b`	|
|	`a.issuperset(b)`	|	>=	|	`True` jeśli wszystkie elementy `b` są zawarte w `a`	|
|	`a.isdisjoint(b)`	|	Nie dotyczy	|	`True` jeśli `a` i `b` nie mają wspólnych elementów	|

Przykłady:

`add`

```{python}
a
a.add(10)
```

`clear`

```{python}
a.clear()
a
```

`remove`

```{python}
a = {1, 2, 3, 4, 5, 10}
a.remove(10)
a
```

`pop`

```{python}
a = {1, 2, 3, 4, 5, 10}
a.pop()
a
```

`update`

```{python}
a = {1, 2, 3, 4}
b = {1, 2, 3, 6}
a.update(b) # łączy, ale nie powiela 
a
```

`intersection_update`

```{python}
a = {1, 2, 3, 4, 5}
b = {1, 2, 6, 7, 8}
a.intersection_update(b)
a
```

`difference`

```{python}
a = {1, 2, 3, 4, 5}
b = {1, 2, 6, 7, 8}
a.difference(b)
a
```

`difference_update`

```{python}
a = {1, 2, 3, 4, 5}
b = {1, 2, 6, 7, 8}
a.difference_update(b)
a
```

:::{.callout-note appearance="simple"}
Jeśli przekażesz dane wejściowe, które nie są `set`, do metod takich jak `union` i `intersection`, Python przekonwertuje dane wejściowe na zestaw przed wykonaniem operacji. Podczas korzystania z `operatorów binarnych` oba obiekty muszą być już ustawione.
:::

Wszystkie logiczne operacje na zbiorach mają odpowiedniki w miejscu, które umożliwiają zastąpienie zawartości zestawu po lewej stronie operacji wynikiem. W przypadku bardzo dużych zestawów może to być bardziej wydajne:


```{python}
a = {1, 2, 3, 4, 5}
b = {1, 2, 6, 7, 8}

c = a.copy()
print(c)

a |= b
a
```

```{python}
d = a.copy()
print(d)

d &= b
d
```

Podobnie jak `key` w `dict`, elementy `set`  muszą być niezmienne i muszą dawać się haszować (co oznacza, że ​​wywołanie `hash` wartości nie zgłasza błędu). Aby przechowywać elementy podobne do `list` (lub inne zmienne sekwencje) w `set`, możesz przekonwertować je na krotki:

```{python}
my_list = [1, 2, 3, 4]
my_set = {tuple(my_list)}
type(my_set)
```

Możesz także sprawdzić, czy zbiór jest podzbiorem (jest zawarty w) lub nadzbiorem (zawiera wszystkie elementy) innego zbioru:

## Funkcje 



## Pliki i Sytstem operacyjny

